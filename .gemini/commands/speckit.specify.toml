description = "從自然語言的功能描述中建立或更新功能規格。"

prompt = """
---
description: 從自然語言的功能描述中建立或更新功能規格。
---

## 使用者輸入

```text
$ARGUMENTS
```

在繼續之前，您 **必須** 考慮使用者輸入（如果不為空）。

## 綱要

使用者在觸發訊息中 `/speckit.specify` 後輸入的文字 **就是** 功能描述。即使 `{{args}}` 在下面顯示為字面值，也要假設您在此對話中始終可以取用它。除非使用者提供了空命令，否則不要要求使用者重複它。

根據該功能描述，執行以下操作：

1. **為分支產生一個簡潔的短名稱**（2-4 個詞）：
   - 分析功能描述並提取最有意義的關鍵字
   - 建立一個 2-4 個詞的短名稱，以捕捉功能的精髓
   - 盡可能使用「動詞-名詞」格式（例如，「add-user-auth」、「fix-payment-bug」）
   - 保留技術術語和縮寫（OAuth2、API、JWT 等）
   - 保持簡潔，但要足夠描述性，以便一眼就能理解功能
   - 範例：
     - 「我想新增使用者認證」→「user-auth」
     - 「為 API 實作 OAuth2 整合」→「oauth2-api-integration」
     - 「為分析建立一個儀表板」→「analytics-dashboard」
     - 「修復支付處理超時錯誤」→「fix-payment-timeout」

2. 從儲存庫根目錄執行腳本 `.specify/scripts/bash/create-new-feature.sh --json "{{args}}"` **並附上短名稱參數**，然後解析其 JSON 輸出以獲取 BRANCH_NAME 和 SPEC_FILE。所有檔案路徑必須是絕對路徑。

   **重要提示**：

   - 將您在步驟 1 中建立的 2-4 個詞的短名稱作為參數附加到 `.specify/scripts/bash/create-new-feature.sh --json "{{args}}"` 命令中
   - Bash: `--short-name "your-generated-short-name"`
   - PowerShell: `-ShortName "your-generated-short-name"`
   - 對於參數中的單引號，如 "I'm Groot"，請使用轉義語法：例如 'I'\''m Groot'（如果可能，或使用雙引號："I'm Groot"）
   - 您只能執行此腳本一次
   - JSON 會作為輸出在終端機中提供 - 務必參考它以獲取您要尋找的實際內容

3. 載入 `.specify/templates/spec-template.md` 以了解必要的章節。

4. 遵循此執行流程：

    1. 從輸入中解析使用者描述
       如果為空：錯誤「未提供功能描述」
    2. 從描述中提取關鍵概念
       識別：角色、動作、資料、限制
    3. 對於不清楚的方面：
       - 根據上下文和行業標準做出明智的猜測
       - 僅在以下情況下標記 `[NEEDS CLARIFICATION: specific question]`：
         - 該選擇會顯著影響功能範疇或使用者體驗
         - 存在多種合理的解釋，且其含義不同
         - 不存在合理的預設值
       - **限制：總共最多 3 個 `[NEEDS CLARIFICATION]` 標記**
       - 按影響力對澄清事項進行優先級排序：範疇 > 安全/隱私 > 使用者體驗 > 技術細節
    4. 填寫「使用者場景與測試」部分
       如果沒有清晰的使用者流程：錯誤「無法確定使用者場景」
    5. 產生功能性需求
       每個需求都必須是可測試的
       對未指定的細節使用合理的預設值（在「假設」部分記錄假設）
    6. 定義成功標準
       建立可衡量的、與技術無關的成果
       包括量化指標（時間、性能、數量）和質化指標（使用者滿意度、任務完成率）
       每個標準都必須在不知道實作細節的情況下可被驗證
    7. 識別關鍵實體（如果涉及資料）
    8. 返回：成功（規格已準備好進行規劃）

5. 使用範本結構將規格寫入 SPEC_FILE，用從功能描述（參數）中推導出的具體細節替換預留位置，同時保留章節順序和標題。

6. **規格品質驗證**：在撰寫初始規格後，根據品質標準對其進行驗證：

   a. **建立規格品質檢查清單**：在 `FEATURE_DIR/checklists/requirements.md` 處使用檢查清單範本結構產生一個檢查清單檔案，包含以下驗證項目：
   
      ```markdown
      # 規格品質檢查清單：[功能名稱]
      
      **目的**：在進入規劃階段前，驗證規格的完整性和品質
      **建立日期**：[日期]
      **功能**：[連結到 spec.md]
      
      ## 內容品質
      
      - [ ] 無實作細節（語言、框架、API）
      - [ ] 專注於使用者價值和業務需求
      - [ ] 為非技術利害關係人撰寫
      - [ ] 所有強制性章節均已完成
      
      ## 需求完整性
      
      - [ ] 不再有 `[NEEDS CLARIFICATION]` 標記
      - [ ] 需求是可測試且無歧義的
      - [ ] 成功標準是可衡量的
      - [ ] 成功標準與技術無關（無實作細節）
      - [ ] 所有驗收場景都已定義
      - [ ] 邊界案例已識別
      - [ ] 範疇已明確界定
      - [ ] 依賴項和假設已識別
      
      ## 功能準備度
      
      - [ ] 所有功能性需求都有清晰的驗收標準
      - [ ] 使用者場景涵蓋了主要流程
      - [ ] 功能符合「成功標準」中定義的可衡量成果
      - [ ] 規格中沒有洩漏任何實作細節
      
      ## 備註
      
      - 標記為未完成的項目需要在執行 `/speckit.clarify` 或 `/speckit.plan` 之前更新規格
      ```
   
   b. **執行驗證檢查**：根據每個檢查清單項目審查規格：
      - 對於每個項目，確定其通過或失敗
      - 記錄發現的具體問題（引用相關的規格章節）
   
   c. **處理驗證結果**：
      
      - **如果所有項目都通過**：將檢查清單標記為已完成，並繼續執行步驟 6
      
      - **如果項目失敗（不包括 `[NEEDS CLARIFICATION]`）**：
        1. 列出失敗的項目和具體問題
        2. 更新規格以解決每個問題
        3. 重新執行驗證，直到所有項目都通過（最多 3 次迭代）
        4. 如果 3 次迭代後仍有失敗項目，則在檢查清單備註中記錄剩餘問題並警告使用者
      
      - **如果仍有 `[NEEDS CLARIFICATION]` 標記**：
        1. 從規格中提取所有 `[NEEDS CLARIFICATION: ...]` 標記
        2. **限制檢查**：如果存在超過 3 個標記，則僅保留 3 個最關鍵的（按範疇/安全/使用者體驗影響力），其餘的則做出明智的猜測
        3. 對於每個需要澄清的事項（最多 3 個），以下列格式向使用者呈現選項：
        
           ```markdown
           ## 問題 [N]：[主題]
           
           **上下文**：[引用相關的規格章節]
           
           **我們需要知道**：[來自 NEEDS CLARIFICATION 標記的具體問題]
           
           **建議答案**：
           
           | 選項 | 答案 | 影響 |
           |--------|--------|--------------|
           | A      | [第一個建議答案] | [這對功能的意義] |
           | B      | [第二個建議答案] | [這對功能的意義] |
           | C      | [第三個建議答案] | [這對功能的意義] |
           | 自訂 | 提供您自己的答案 | [解釋如何提供自訂輸入] |
           
           **您的選擇**：_[等待使用者回應]_
           ```
        
        4. **關鍵 - 表格格式**：確保 markdown 表格格式正確：
           - 使用一致的間距，使管道符對齊
           - 每個儲存格的內容周圍應有空格：`| 內容 |` 而不是 `|內容|`
           - 標頭分隔符必須至少有 3 個破折號：`|--------|`
           - 測試表格在 markdown 預覽中是否能正確渲染
        5. 順序編號問題（Q1, Q2, Q3 - 總共最多 3 個）
        6. 在等待回應前，一次性呈現所有問題
        7. 等待使用者對所有問題做出選擇（例如，「Q1: A, Q2: 自訂 - [細節], Q3: B」）
        8. 用使用者選擇或提供的答案替換每個 `[NEEDS CLARIFICATION]` 標記，以更新規格
        9. 在所有澄清事項都解決後，重新執行驗證
   
   d. **更新檢查清單**：每次驗證迭代後，用當前的通過/失敗狀態更新檢查清單檔案

7. 報告完成情況，包括分支名稱、規格檔案路徑、檢查清單結果，以及是否準備好進入下一階段（`/speckit.clarify` 或 `/speckit.plan`）。

**注意：** 該腳本會在寫入之前建立並切換到新分支，並初始化規格檔案。

## 一般指南

## 快速指南

- 專注於使用者 **需要什麼** 以及 **為什麼**。
- 避免 **如何** 實作（不涉及技術堆疊、API、程式碼結構）。
- 為業務利害關係人撰寫，而非開發人員。
- **不要** 在規格中嵌入任何檢查清單。這將是一個獨立的命令。

### 章節要求

- **強制性章節**：每個功能都必須完成
- **可選章節**：僅在與功能相關時包含
- 當某個章節不適用時，完全移除它（不要留著寫「不適用」）

### 對於 AI 生成

從使用者提示建立此規格時：

1. **做出明智的猜測**：使用上下文、行業標準和常見模式來填補空白
2. **記錄假設**：在「假設」部分記錄合理的預設值
3. **限制澄清事項**：最多 3 個 `[NEEDS CLARIFICATION]` 標記 - 僅用於滿足以下條件的關鍵決策：
   - 顯著影響功能範疇或使用者體驗
   - 存在多種合理的解釋，且其含義不同
   - 缺乏任何合理的預設值
4. **對澄清事項進行優先級排序**：範疇 > 安全/隱私 > 使用者體驗 > 技術細節
5. **像測試人員一樣思考**：每個模糊的需求都應該在「可測試且無歧義」的檢查清單項目上失敗
6. **常見需要澄清的領域**（僅當不存在合理的預設值時）：
   - 功能範疇和邊界（包含/排除特定的使用案例）
   - 使用者類型和權限（如果可能存在多種相互衝突的解釋）
   - 安全/合規性需求（當具有法律/財務上的重大意義時）
   
**合理預設值的範例**（不要問這些）：

- 資料保留：該領域的行業標準實踐
- 性能目標：除非特別指定，否則為標準的網頁/行動應用程式期望
- 錯誤處理：使用者友好的訊息及適當的後備方案
- 認證方法：對於網頁應用程式，為標準的基於會話或 OAuth2
- 整合模式：除非另有說明，否則為 RESTful API

### 成功標準指南

成功標準必須是：

1. **可衡量的**：包括具體指標（時間、百分比、計數、速率）
2. **與技術無關的**：不提及框架、語言、資料庫或工具
3. **以使用者為中心的**：從使用者/業務的角度描述成果，而非系統內部
4. **可驗證的**：在不知道實作細節的情況下可以被測試/驗證

**好的範例**：

- 「使用者可以在 3 分鐘內完成結帳」
- 「系統支援 10,000 個並行使用者」
- 「95% 的搜尋在 1 秒內返回結果」
- 「任務完成率提高 40%」

**不好的範例**（以實作為中心）：

- 「API 回應時間低於 200 毫秒」（太技術性，應使用「使用者立即看到結果」）
- 「資料庫可以處理 1000 TPS」（實作細節，應使用面向使用者的指標）
- 「React 組件高效渲染」（特定於框架）
- 「Redis 快取命中率高於 80%」（特定於技術）
"