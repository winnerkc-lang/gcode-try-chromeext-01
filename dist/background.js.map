{"version":3,"file":"background.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AEvFA;AACA;AACA;AACA;AACA","sources":["webpack://chrome-extension-ts-webpack/./src/servicework/background.ts","webpack://chrome-extension-ts-webpack/webpack/before-startup","webpack://chrome-extension-ts-webpack/webpack/startup","webpack://chrome-extension-ts-webpack/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// src/servicework/background.ts\nconsole.log('background script loaded');\n// Normalize bookmark.json contents to a consistent shape:\n// { version: number, items: Array }\nfunction normalizeBookmarksData(parsed) {\n    var _a, _b;\n    if (Array.isArray(parsed)) {\n        return { version: 1, items: parsed };\n    }\n    if (parsed && typeof parsed === 'object') {\n        const parsedObj = parsed;\n        const versionRaw = parsedObj.version;\n        // Coerce version to a safe integer >= 0\n        let version = 1;\n        if (typeof versionRaw === 'number' && Number.isFinite(versionRaw)) {\n            version = Math.max(0, Math.floor(versionRaw));\n        }\n        else if (versionRaw) {\n            const maybeNumber = Number(versionRaw);\n            version = Number.isFinite(maybeNumber) ? Math.max(0, Math.floor(maybeNumber)) : 1;\n        }\n        const itemsCandidate = (_b = (_a = parsedObj.bookmarks) !== null && _a !== void 0 ? _a : parsedObj.items) !== null && _b !== void 0 ? _b : parsedObj.data;\n        const items = Array.isArray(itemsCandidate) ? itemsCandidate : [];\n        return { version, items };\n    }\n    return { version: 1, items: [] };\n}\nfunction loadBookmarksFromFile() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const response = yield fetch(chrome.runtime.getURL('bookmark.json'));\n            const parsed = yield response.json();\n            return normalizeBookmarksData(parsed);\n        }\n        catch (err) {\n            console.error('Error loading or parsing bookmark.json:', err);\n            return null;\n        }\n    });\n}\nfunction initBookmarksFromFile() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const newBookmarks = yield loadBookmarksFromFile();\n        if (!newBookmarks)\n            return;\n        chrome.storage.local.get('bookmarks', (result) => {\n            var _a;\n            const current = result.bookmarks;\n            const currentVersionRaw = current && ((_a = current.version) !== null && _a !== void 0 ? _a : 0);\n            const currentVersion = Number.isFinite(Number(currentVersionRaw)) ? Math.max(0, Math.floor(Number(currentVersionRaw))) : 0;\n            const newVersion = Number.isFinite(Number(newBookmarks.version)) ? Math.max(0, Math.floor(Number(newBookmarks.version))) : 0;\n            if (!current || newVersion > currentVersion) {\n                const itemsWithIds = (Array.isArray(newBookmarks.items) ? newBookmarks.items : []).map((item, index) => (Object.assign(Object.assign({}, item), { id: item.id || Date.now() + index })));\n                const toStore = { version: newVersion, items: itemsWithIds };\n                chrome.storage.local.set({ bookmarks: toStore }, () => {\n                    console.log('Bookmarks initialized/updated in local storage. (version)', newVersion);\n                });\n            }\n            else {\n                console.log('Bookmarks in local storage are up-to-date. (current version)', currentVersion);\n            }\n        });\n    });\n}\n// Run on installed (first install or extension update)\nchrome.runtime.onInstalled.addListener((details) => __awaiter(void 0, void 0, void 0, function* () {\n    if (details.reason === 'install' || details.reason === 'update') {\n        yield initBookmarksFromFile();\n    }\n}));\n// Run on startup (service worker activation) to ensure initialization on worker load\nchrome.runtime.onStartup.addListener(() => {\n    void initBookmarksFromFile();\n});\n// Also attempt immediate initialization when the service worker loads.\n// Use an async IIFE to avoid lint warnings about top-level async calls.\n// Initialize without top-level await to remain compatible with the project's TS target.\n// Initialization happens in onInstalled and onStartup handlers.\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[\"./src/servicework/background.ts\"].call(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}